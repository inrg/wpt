<!DOCTYPE html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-constants.js"></script>
<script src="resources/webxr_util.js"></script>
<script src="resources/xr-test-asserts.js"></script>
<canvas></canvas>

<script>

let immersiveTestName = "XRFrame.getPose works for immersive sessions";
let nonImmersiveTestName = "XRFrame.getPose works for non-immersive sessions";

let fakeDeviceInitParams = { supportsImmersive:true };
let immersiveSessionOptions = { mode: 'immersive-vr' };
let nonImmersiveSessionOptions = { outputContext: getOutputContext() };

// XRRigidTransform attributes are read only, so create a new transform
let translateTransform = function(tr, xOffset, yOffset, zOffset) {
  let newPoint = DOMPointReadOnly.fromPoint({
    x : tr.position.x + xOffset,
    y : tr.position.y + yOffset,
    z : tr.position.z + zOffset
  });
  return new XRRigidTransform(newPoint, tr.orientation);
};

let adjustTransformRotation = function(tr, quaternion) {
  return new XRRigidTransform(tr.position, quaternion);
};

// only works when quaternion has pitch, but zero yaw and roll
function getPichAngle(quaternion) {
  return 2.0 * Math.acos(quaternion.w);
}

// make a quaternion that rotates by radians amount around the y axis (pitch)
function setPitchAngle(radians) {
  return DOMPointReadOnly.fromPoint({
    x : 0.0,
    y : Math.sin(radians / 2.0),
    z : 0.0,
    w : Math.cos(radians / 2.0)
  });
}

let testFunction = function(session, fakeDeviceController, t) {
  // Need to have a valid pose or input event's don't process.
  fakeDeviceController.setXRPresentationFrameData(VALID_POSE_MATRIX, [{
      eye:"left",
      projectionMatrix: VALID_PROJECTION_MATRIX,
      viewMatrix: VALID_VIEW_MATRIX
    }, {
      eye:"right",
      projectionMatrix: VALID_PROJECTION_MATRIX,
      viewMatrix: VALID_VIEW_MATRIX
    }]);

  return Promise.all([
    session.requestReferenceSpace({ type: "stationary", subtype: "eye-level" }),
    session.requestReferenceSpace({ type: "stationary", subtype: "eye-level" })
  ]).then((spaces) => new Promise((resolve) => {
    function onFrame(time, xrFrame) {
      // both eye-level spaces start out with originOffset = identity matrix
      let space1 = spaces[0];
      let space2 = spaces[1];

      // rotate space2 around the y axis and apply some translation
      space2.originOffset = adjustTransformRotation(space2.originOffset, setPitchAngle(Math.PI / 4.0));
      space2.originOffset = translateTransform(space2.originOffset, 1.0, 2.0, 3.0);

      // Get a pose with a transform that maps from space2 to space1.
      // Because space1's originOffset is the identity matrix, mapping from space2
      // to space1 should be the inverse of space2's originOffset matrix.
      let pose = xrFrame.getPose(space1, space2);
      assert_matrices_are_inverse(pose.transform.matrix, space2.originOffset.matrix);

      // Get a pose with a transform that maps from space1 to space2.
      // Going from space1 (identity) to space2 should simply use space2's
      // originOffset matrix.
      pose = xrFrame.getPose(space2, space1);
      assert_matrix_approx_equals(pose.transform.matrix, space2.originOffset.matrix, FLOAT_EPSILON);

      // Also make some adjustments to space1.
      // transform going from space 1 to 2 should be inverse of transform that
      // goes from space 2 to 1
      space1.originOffset = adjustTransformRotation(space1.originOffset, setPitchAngle(Math.PI / 8.0));
      space1.originOffset = translateTransform(space1.originOffset, 2.0, 3.0, 4.0);
      let pose_2_1 = xrFrame.getPose(space1, space2);
      let pose_1_2 = xrFrame.getPose(space2, space1);
      assert_matrices_are_inverse(pose_2_1.transform.matrix, pose_1_2.transform.matrix);

      // Finished test.
      resolve();
    }

    session.requestAnimationFrame(onFrame);
  }));
};

xr_session_promise_test(immersiveTestName, testFunction,
  fakeDeviceInitParams, immersiveSessionOptions);
xr_session_promise_test(nonImmersiveTestName, testFunction,
  fakeDeviceInitParams, nonImmersiveSessionOptions);

</script>
